# 🤖 멀티 에이전트 RAG 시스템

## 🎯 개요

여러 개의 PDF로 분할된 문서를 **멀티 에이전트 구조**로 처리하는 고급 RAG 시스템입니다.

## 🏗️ 시스템 아키텍처

```
                    사용자 질문
                         ↓
        ┌────────────────┼────────────────┐
        ↓                ↓                ↓
   [에이전트 1]      [에이전트 2]      [에이전트 3]      [에이전트 4]
   PDF 1 담당        PDF 2 담당        PDF 3 담당        PDF 4 담당
        ↓                ↓                ↓                ↓
     답변 1            답변 2            답변 3            답변 4
        └────────────────┼────────────────┘
                         ↓
                  [코디네이터 에이전트]
                  (답변 평가 및 종합)
                         ↓
                    최종 답변
```

## 🔄 처리 과정

### 1단계: 에이전트 초기화
```python
PDF 폴더 → 4개 PDF 발견
    ↓
각 PDF별로 에이전트 생성:
- 에이전트 1: PDF_1.pdf
- 에이전트 2: PDF_2.pdf
- 에이전트 3: PDF_3.pdf
- 에이전트 4: PDF_4.pdf
    ↓
각 에이전트가 독립적인 RAG 체인 보유
```

### 2단계: 질문 처리 (병렬)
```python
사용자 질문 → "전형별 모집 인원은?"
    ↓
병렬 처리 (ThreadPoolExecutor):
- 에이전트 1 → 답변 생성 (PDF 1 기반)
- 에이전트 2 → 답변 생성 (PDF 2 기반)
- 에이전트 3 → 답변 생성 (PDF 3 기반)
- 에이전트 4 → 답변 생성 (PDF 4 기반)
    ↓
4개 답변 수집 완료
```

### 3단계: 코디네이터 평가
```python
코디네이터가 4개 답변 분석:
    ↓
평가 기준:
1. 질문과의 관련성
2. 정보의 정확성
3. 정보의 완전성
    ↓
최적 답변 선택 또는 통합
    ↓
최종 답변 생성
```

## 💡 주요 장점

### 1. **병렬 처리**
```python
# 4개 에이전트가 동시에 작업
with ThreadPoolExecutor(max_workers=4):
    # 처리 시간 = 단일 에이전트 시간 (4배 빠르지 않지만 효율적)
```

### 2. **정보 보완**
```
에이전트 1 답변: "인문캠퍼스 정보"
에이전트 2 답변: "자연캠퍼스 정보"
에이전트 3 답변: "국제캠퍼스 정보"
에이전트 4 답변: "전체 요약"
    ↓
코디네이터: 모든 캠퍼스 정보 통합
```

### 3. **견고성**
```
에이전트 1 → 오류
에이전트 2 → 답변 ✅
에이전트 3 → 답변 ✅
에이전트 4 → 답변 ✅
    ↓
코디네이터: 나머지 3개로 답변 생성
```

## 🚀 사용 방법

### 1. PDF 분할 준비
```bash
임베딩_기반/
└── 경희대_수시요강_분할표/
    ├── 경희대_수시요강_1.pdf  # 1~32페이지
    ├── 경희대_수시요강_2.pdf  # 33~64페이지
    ├── 경희대_수시요강_3.pdf  # 65~96페이지
    └── 경희대_수시요강_4.pdf  # 97~128페이지
```

### 2. 시스템 실행
```bash
streamlit run app_multi_agent.py
```

### 3. 에이전트 초기화
1. 사이드바에서 폴더 경로 확인/수정
2. "PDF 로드 및 에이전트 생성" 버튼 클릭
3. 4개 에이전트 생성 대기 (2-3분)

### 4. 질문하기
```
질문: "네오르네상스 전형 모집 인원은?"
    ↓
[에이전트 1] 답변...
[에이전트 2] 답변...
[에이전트 3] 답변...
[에이전트 4] 답변...
    ↓
[코디네이터] 최종 통합 답변
```

## 📊 성능 비교

### 단일 에이전트 vs 멀티 에이전트

| 항목 | 단일 에이전트 | 멀티 에이전트 |
|------|-------------|-------------|
| **초기화 시간** | 1-2분 | 2-3분 |
| **질문 응답 시간** | 3-5초 | 10-15초 |
| **정확도** | ⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ |
| **정보 범위** | 단일 문서 | 분할 문서 전체 |
| **견고성** | 중간 | 높음 |

### 언제 사용할까?

**단일 에이전트 (app.py):**
- ✅ 빠른 답변 필요
- ✅ 단일 PDF 문서
- ✅ 일반적인 질문

**멀티 에이전트 (app_multi_agent.py):**
- ✅ 분할된 대용량 문서
- ✅ 포괄적인 답변 필요
- ✅ 정확도 최우선
- ✅ 복잡한 비교 질문

## 🔧 코디네이터 동작 원리

### 평가 및 선택
```python
# 코디네이터 프롬프트 일부
"""
**평가 기준:**
1. 질문과의 관련성
2. 정보의 정확성과 구체성
3. 정보의 완전성

**작업 지침:**
1. 각 에이전트의 답변을 분석하세요
2. 가장 관련성 높고 정확한 정보를 선택하세요
3. 여러 답변에 보완적인 정보가 있다면 통합하세요
"""
```

### 예시: 답변 통합

**질문:** "경영학과 수시 모집 인원은?"

**에이전트 답변들:**
```
[에이전트 1] "인문캠퍼스 경영학과: 30명"
[에이전트 2] "자연캠퍼스는 경영학과 없음"
[에이전트 3] "학생부종합: 20명, 논술: 10명"
[에이전트 4] "경영학과 총 30명 (인문캠)"
```

**코디네이터 최종 답변:**
```
경희대학교 경영학과 수시 모집 인원은 총 30명입니다.

- 캠퍼스: 인문캠퍼스
- 전형별 인원:
  * 학생부종합전형: 20명
  * 논술전형: 10명

(자연캠퍼스에는 경영학과가 없습니다)
```

## 📈 확장 가능성

### 1. 더 많은 에이전트
```python
# 10개 PDF → 10개 에이전트
agents = load_multi_agents("대용량_문서_폴더")
# 병렬 처리로 효율적 관리
```

### 2. 전문화된 에이전트
```python
agents = [
    {"name": "전형_전문", "specialty": "전형 정보"},
    {"name": "학과_전문", "specialty": "학과 정보"},
    {"name": "일정_전문", "specialty": "일정 정보"},
    {"name": "통합_전문", "specialty": "전체 개요"}
]
```

### 3. 계층적 코디네이터
```
         [마스터 코디네이터]
                 ↓
        ┌────────┴────────┐
  [서브 코디네이터1]  [서브 코디네이터2]
        ↓                    ↓
   에이전트 1,2         에이전트 3,4
```

## 🎯 실전 활용

### 시나리오 1: 복잡한 비교 질문
```
질문: "학생부종합전형과 논술전형을 비교해주세요"

처리:
- 에이전트 1: 학생부종합 페이지 검색
- 에이전트 2: 논술전형 페이지 검색
- 에이전트 3: 전형 비교표 검색
- 에이전트 4: 전체 개요 검색
    ↓
코디네이터: 체계적인 비교표 생성
```

### 시나리오 2: 캠퍼스별 정보
```
질문: "캠퍼스별 모집 인원 차이는?"

처리:
- 각 에이전트가 담당 PDF에서 캠퍼스 정보 추출
- 코디네이터가 캠퍼스별로 정리하여 비교
```

## ⚠️ 주의사항

### 1. 초기화 시간
- 4개 PDF 처리에 2-3분 소요
- 캐싱되므로 재시작 시 빠름

### 2. API 사용량
```
단일 질문 = 에이전트 답변 4회 + 코디네이터 1회
           = 총 5회 LLM 호출
```

### 3. 메모리 사용
- 4개 벡터스토어 동시 메모리 로드
- 권장: 8GB 이상 RAM

## 🚀 최적화 팁

### 1. 캐싱 활용
```python
@st.cache_resource
def load_multi_agents(folder_path):
    # 한 번만 로드, 이후 재사용
```

### 2. 병렬 처리
```python
# ThreadPoolExecutor로 동시 처리
with ThreadPoolExecutor(max_workers=4):
    # 4배 빠른 답변 수집
```

### 3. 에이전트 검색 수 조정
```python
# 멀티 에이전트이므로 개별 검색 수는 줄임
"k": 15  # 단일: 20, 멀티: 15
```

## 📝 결론

멀티 에이전트 시스템은:
- ✅ 분할 문서 완벽 처리
- ✅ 정보 누락 최소화
- ✅ 높은 정확도
- ⚠️ 조금 느린 속도
- ⚠️ 높은 API 사용량

**용도에 맞게 선택하세요:**
- 빠른 답변: `app.py`
- 표 전문: `app_multimodal.py`
- 분할 문서: `app_multi_agent.py` ✨

